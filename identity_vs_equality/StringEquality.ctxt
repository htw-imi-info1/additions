#BlueJ class context
comment0.target=StringEquality
comment0.text=\n\ It\ is\ important\ to\ understand\ the\ difference\ between\ \n\ \n\ -\ object\ identity,\ tested\ with\ \=\=\ and\ \n\ -\ object\ equality,\ tested\ with\ equals()\n\ \n\ if\ you're\ working\ with\ strings,\ because\ you\ may\ introduce\ bugs\ in\ your\ \n\ code\ if\ you\ use\ \=\=\ where\ you\ should\ use\ equals()\ (and\ vice\ versa)\n\ \n\ Using\ String\ itself\ to\ illustrate\ the\ difference\ though\ is\ tricky,\ \n\ because\ the\ case\ with\ strings\ is\ a\ bit\ more\ complicated.\n\ \n\ tl;dr\:\ always\ use\ equals()\ in\ java\ if\ you\ want\ to\ compare\ two\ strings,\ and\ \n\ use\ the\ Address\ example\ to\ understand\ the\ difference.\n\n\ \n\ yet,\ sometimes\ s1\ \=\=\ s2\ also\ works,\ and\ here's\ why\:\n\ \n\ \n\ Strings\ are\ more\ tricky\ for\ this\ exercise\ as\ they\ are\n\ -\ immutable\ (can't\ be\ modified\ as\ Address(es)\ with\ setStreet()\ above)\ and\ thus\n\ -\ can\ be\ interned,\ that\ is,\ equal\ strings\ can\ share\ one\ String\ Object\ \n\ \ \ (which\ helps\ optimization\:\ less\ space,\ faster\ comparision)\n\ \ \ \n\ see\ https\://www.baeldung.com/java-string-pool\n\ and\ https\://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html\#jls-3.10.5\n\ if\ you\ want\ to\ know\ the\ details.\ But\ you\ really\ don't\ need\ to\ know\ them\!\n\ \n\ \n
comment1.params=
comment1.target=void\ illustrateStringInterning()
comment1.text=\n\ This\ example\ illustrates\ String\ interning\n
comment2.params=
comment2.target=void\ newExerciseWithStrings()
comment2.text=\n\ thus,\ the\ results\ of\ the\ exercise\ differ,\n\ depending\ wether\ the\ equal\ strings\ are\ interned\:\n
comment3.params=
comment3.target=void\ newExerciseWithStringsInterned()
comment4.params=
comment4.target=void\ specExample()
comment4.text=\n\ This\ example\ illustrates\ six\ points\:\n\ \n\ 1.\ (initial\ string,\ points\ 2-7\ are\ the\ six\ points\:)\n\n\ \ \ \ 2.\ String\ literals\ in\ the\ same\ class\ and\ package\ represent\ references\ to\ the\ same\ String\ object\ (\u00A74.3.1).\n\n\ \ \ \ 3.\ String\ literals\ in\ different\ classes\ in\ the\ same\ package\ represent\ references\ to\ the\ same\ String\ object.\n\n\ \ \ \ 4.\ String\ literals\ in\ different\ classes\ in\ different\ packages\ likewise\ represent\ references\ to\ the\ same\ String\ object.\n\n\ \ \ \ 5.\ Strings\ concatenated\ from\ constant\ expressions\ (\u00A715.29)\ are\ computed\ at\ compile\ time\ and\ then\ treated\ as\ if\ they\ were\ literals.\n\n\ \ \ \ 6.\ Strings\ computed\ by\ concatenation\ at\ run\ time\ are\ newly\ created\ and\ therefore\ distinct.\n\n\ \ \ \ 7.\ The\ result\ of\ explicitly\ interning\ a\ computed\ string\ is\ the\ same\ String\ object\ as\ any\ pre-existing\ string\ literal\ with\ the\ same\ contents.\n\ \ \ \ \ \n\ \ \ \ Thus,\ only\ 6.\ results\ in\ a\ distinct\ instance.\ But\:\ \n\ \ \ \ \n\ \ \ \ 8.\ according\ to\ the\ documentation\ of\ the\ String(String\ original)\ constructor\ in\ String,\ this\ also\ creates\ a\ new\ object\n\ \ \ \ \n\ \ \ \ @see\ https\://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html\#%3Cinit%3E(java.lang.String)\n\ \ \ \ \n\ \ \ \ 9.\ which\ again\ can\ be\ explicity\ interned.\n
numComments=5
